Intro:
'Informatica - Una panoramica Generale' + 'Computer Science di Kevin Wayne (Java)'

2	Definizione di algoritmo
8	Arte della risoluzione dei problemi
17	Ricorsione
21	Efficienza degli algoritmi (v. 98)
43	Commenti
52	Introduzione alla OOP
54	Costruttori
54	Caratteristiche (ereditarietà e incapsulamento) (v. 181-201)
66	Array e Linked Lists (v. 82 Java + 84 CPP x implementazione) 
67	Alberi (v. 111 Java x implementazione)
79	Tipi di dati definiti dall'utente (v. 131)
90	Macchine di Turing
95	Funzioni non computabili
98	Complessità dei problemi (v. 41)
102	Crittografia
109	Iterazione vs Ricorsione

111	Reference types
113	Comparazione di oggetti (v. 203 + 6 Java x diagramma)
113	Pass by value
114	Array
115	Puntatori
116	Garbage collector
131	Creare tipi di dato
133	Modificatori di accesso e variabili d'istanza (v. 6 Java x modificatori 'public e 'private'
138	Com'è fatta una classe?
143	Programmazione grafica (introduzione a StdDraw)
177	Progettare tipi di dato
181	Incapsulamento
194	'this' keyword
195	Interfaccie e polimorfismo
199	Funzioni lambda
201	Ereditarietà
203	Comparazione di oggetti (2)
206	Tipi Wrapper
214	Eccezioni (v. 15 CPP x confronto)
215	'assert' keyword





CPP:'C++ Primer 5th Edition di Stanley B. Lippman' + 'Problem Solving with C++ 10th Edition Global di W. Savitch'

1   Type Aliases
2   'auto' type
4   'decltype' keyword
6   Introduzione alle classi (v. 19)
10  Scrivere il proprio file header
12  Iterators (v. 89)
19  Classi (v. 6)
27  Costruttori (v. 53)
32  Copy e distruzione
34  'friend' keyword
36  Funzionalità avanzate delle classi
47  Scope delle classi
53  Costruttori avanzati (v. 27)
65  Membri static
70  Classi IO (v. 272)
76  Gestione di file
81  Stream di 'string' (v. string in seguito)
84  Containers sequenziali (v. 66 Intro + 374 per implementazione vettori)
88  Operazioni con i Containers sequenziali (v. 95)
89  Iterators (v. 12-131)
95  Operazioni con i containers sequenziali (v. 88)
106 Introduzione agli algoritmi della Standard Lib (v 2-8 intro)
113 Algoritmi di ordinamento
118 Funzioni lambda
131 Iterators (v. 12-89)
145 Algoritmi per i containers
147 Containers Associativi
155 Operazioni con i containers Associativi
170 Containers Associativi unordered
174 Progetto: Query program
180 Introduzione all'OOP (v. 52 intro)
192 Funzioni virtual
196 Classi astratte
199 Modificatori di accesso
210 Costruttori (Ereditarietà)
222 Progetto: Text Query rivisitato
237 classe 'tuple'
242 Classe 'bitset'
247 Espressioni regolari
272 IO Formattato (v. 70)
282 Accesso casuale agli Stream
287 Namespace
304 Ereditarietà multipla
318 Overloading gestione heap
323 Run-Time Type Identification
328 classe 'type_info'
333 Puntatori a membri della classe
339 Callable Objects
341 Nested Classes
345 Classe 'union'
354 Modificatore 'volatile'

360	Classe 'string'
374	classe 'vector' (v. 84)
383	Eccezioni
411	Templates

421	Tabella caratteri ASCII
422	API Reference




Java:
'Java An introduction to problem solving 8th Edition Global di W. Savitch'

1	Classi e metodi
3	File delle classi
4	Incapsulamento (v. 181 intro)
6	Modificatori di accesso 'public' e 'private' (v. 133 intro)
11	Diagramma comparazione di oggetti (v. 113-203 intro)
12	'equals' method
19	Enumeration
21	Ereditarietà (v. 201 intro)
27	Overriding
28	Modificatore 'final'
31	Ereditarietà in UML
34	Ereditarietà 2, keyword 'super'
36	'this' vs 'super' (v. 194 intro per 'this')
38	Polimorfismo (v. 195 intro)
43	Interfaccie (v. 195 intro)
52	Eccezioni (v. 214 intro)
57-58	Diagramma flusso di esecuzione in caso di eccezione
62	Definire eccezioni personalizzate
70	Strutture dinamiche basate su array (v. 114 intro per definizione 'array')
71	classe 'ArrayList'
76	Java Collections Framework
77	classe 'HashSet'
79	Interfaccia 'Map' e classe 'HashMap'
82	Linked Lists (v. 66 intro x descrizione struttura + 115 intro x puntatori)
92	NullPointerException (v. 52)
94	Classi interne
107	Interfaccia 'Iterator' e Exception Handling delle Linked Lists
109	Linked Lists particolari
111	Altre strutture dati Linked (v. 67 intro x alberi)
112	Tipi di dato generici (v. pag. 52 CPP x confronto con templates)




Concorrenza:
"Tecnologie e progettazione di sistemi informatici vol. 2 di P. Camagni"

1	Il modello a processi
3	Stato dei processi
5	Comandi per la gestione (v. 47 x C/C++)
9	Gestione delle risorse
12	Grafi di Holt
22	Thread (v. 76 x C/C++, 96 e 202 x Java)
24	Standard POSIX per i Thread
26	Programmazione imperativa vs concorrente
28	Processi non sequenziali
33	Processi in competizione
35	Fork Join (v. 59)
40	Cobegin-coend (v. 70)
43	Equivalenza tra i due metodi

47	Fork in C/C++
53	Esecuzione non deterministica
59	Funzione wait() in C/C++
70	Fork Join e cobegin-coend in C
76	Thread in C/C++
83	Thread e parametri in C/C++
91	Thread in Java
98	Thread prioritari con parametri in Java
103	sleep(), yeld(), join() in Java

113	Modello di comunicazione a memoria comune
116	Modello a scambio di messaggi

121	Errori nei programmi concorrenti (v. 165 x C/C++)
124	Dominio e rango
127	Mutua esclusione
129	Deadlock (v. 148)
133	Semafori di basso livello (v. 170 x C/C++, 196 x Java)
137	Semafori di Dijkstra
148	Deadlock 2 (v. 175 x C/C++, 207 x Java)
153	Detection, recovery, avoidance
155	Prevention
158	I monitor
216	wait e signal

165	Thread e schedulazione
170	I semafori binari in C
175	Soluzione problema dei filosofi in C
178	Soluzione problema produttori consumatori
189	Variabili condizione in C
196	I semafori in Java
202	I ciclisti: thread in Java
207	Soluzione problema dei filosofi in Java
